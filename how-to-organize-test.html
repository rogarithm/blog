<p>EasyMock으로 테스트 데이터 생성 방식 개선하기</p>
<p>배경	테스트를 자주 짠다</p>
<p>어떤 프로젝트를 하던지 간에 테스트로 내가 짠 코드의 동작을 확인할 수 있도록 환경을 구성하려고 한다. 테스트를 만들어나가면서 개발하는 것이 편해서다.</p>
<p>익숙하지 않은 라이브러리나 처음 쓰는 API는 어떻게 사용하는지 잘 모를 수밖에 없다. 공식 문서나 블로그를 찾아 읽어보며 이들 기능을 익히는 방법도 있지만, 테스트를 만들면서 익힐 수도 있다. 테스트를 만들어보면 '실제 상황'에 대해 주도적으로 생각하게 된다. 어떤 상황에서 이 기능을/라이브러리를/메서드를 쓰려고 하는 건지 생각하게 되고, 어떤 식으로 코드를 짜야할지 막연한 상태에서 벗어나게 된다. 테스트를 어떻게 짜야할지 좀처럼 떠오르지 않는다면, 더 간단한 상황에 대한 테스트를 우선 짜보는 방법으로 난이도를 낮출 수도 있다. 테스트 케이스가 성공하는 것을 눈으로 확인하면서 구현할 기능을 이룰 작은 조각들을 확실하게 이해하고, 더 복잡한, 쓰려고 하는 실제 상황에 맞는 코드를 짤 수 있을 정도로 내 이해를 높여갈 수 있다.</p>
<p>테스트는 짠 코드가 제대로 동작하는지 확인해준다. 생각했던 것과 달리 코드가 제대로 동작하지 않는 상황이 종종 생긴다. 문제는 이런 상황을 더 늦게 발견할수록 문제가 된 원인을 찾는 것도 더 어려워진다는 점이다. 바뀐 부분이 더 많아질수록 문제의 원인이 될 수 있는 부분의 조합도 기하급수적으로 늘어나기 때문이다. 테스트를 짜면서 구현하면 테스트가 실패했을 당시 바뀐 부분으로 발생 원인을 확인할 부분이 좁혀진다. 확인하기도 훨씬 수월하고, 문제가 생겼을 때 해결하는 시간도 짧아진다.</p>
<p>이런 이유로 테스트를 자주, 그리고 많이 짠다.</p>
<p>문제	테스트 때문에 API 구현에 시간이 오래 걸린다</p>
<p>몇 주 전부터 만들고 있는 백엔드 API 프로젝트 진도가 잘 안나갔다. API 하나를 구현하는 데도 시간이 오래 걸렸고, 개발 속도를 높이고 싶었다. 기능 구현에 필요한 이론 공부에 드는 시간도 있었지만, 테스트를 짜느라 시간이 많이 걸린다는 생각이 들었다.</p>
<p>행동	테스트 작성에 왜 시간이 오래 걸리는지를 생각해봤다</p>
<p><API 레이어 구성, 레이어별 적용된 테스트 종류 다이어그램></p>
<p>레이어별로 테스트를 짠다. 컨트롤러, 서비스, DAO 각 레이어별로 테스트를 만든다. 만드는 테스트 종류가 여러가지다. 단위 테스트를 짜고, 거기 더해 통합 테스트와 E2E 테스트도 짠다. 테스트 케이스가 많다. 각 테스트는 발생할 수 있는 케이스를 테스트한다. 뭉뚱그리면 레이어 갯수 X 테스트 종류 X 테스트 케이스 갯수가 곱해진 만큼의 테스트를 각 API마다 만들게 된다.</p>
<p>테스트 데이터를 만드는 코드가 많다. 데이터에 들어갈 값을 일일이 정했다. 각 테스트 메서드에서는 동작을 확인하려는 메서드에 넣을 테스트 데이터를 정의한다. 데이터 타입이 객체일 경우, 들어갈 필드값은 일일이 하드코딩했다. 하드코딩할 필드가 있으면 어떤 값을 집어넣을지 고민했다. 데이터와 연관된 변수 이름을 일일이 정했다. 데이터 참조를 갖는 변수 이름이 케이스와 연관되도록 변수 이름을 고민했다. 각 테스트별 테스트 데이터 갯수 X 각 데이터에 들어갈 필드값을 고민하는 시간 X 각 데이터의 변수 이름을 고민하는 시간이 곱해지니까 테스트 데이터 만드는 데 시간이 걸렸다.</p>
<p>기존 테스트 작성 방식을 분석해보면서, 지금처럼 테스트를 작성해나갔을 때 테스트 작성 시간 이외에도 발생할 다른 문제가 예상되었다.</p>
<p>유지보수하려면 일단 짜놓은 코드를 이해해야 하는데, 직접 짠 코드더라도 며칠만 지나고 나면 다시 읽고 이해해야 했다. 테스트를 다시 읽는데, 내용을 이해하는 데 오래 걸렸다. 테스트가 늘어날수록 코드를 다시 읽고 이해하는데 걸리는 시간도 늘어날테고, 테스트를 읽고 유지보수하는 데 걸리는 시간도 늘어날 것으로 예상되었다.</p>
<p>테스트에 필요한 데이터가 많아질수록 테스트 작성 시간이 증가한다. 예를 들어 pagination 성능 테스트 같이 테스트 하나에서 필요로 하는 데이터 갯수가 매우 많아야 할 경우, 기존 테스트 작성 방식으로는 데이터 생성에 들어가는 시간은 번거로운 정도에서 끝나지 않을 것이다.</p>
<p>결과적으로 테스트 작성 시간뿐 아니라 추가로 예상되는 문제를 해결하기 위해 테스트 작성 방식 개선이 필요하다고 판단했다.</p>
<p>행동	테스트 작성을 오래 걸리게 만드는 점 중 개선할 수 있는 점이 있는지 알아봤다</p>
<p>1. 테스트 케이스 갯수</p>
<p>만약 테스트할 케이스를 줄이면 테스트하지 않은 케이스가 잘 동작하는지 확신할 수 없다. 설계 변경이나 리팩토링 시 테스트로 커버되지 않는 코드의 정상 동작을 보증할 수도 없게 된다. 테스트 구현에 시간이 많이 든다고 해서 테스트를 짜지 않을 수는 없었다. 만약 그렇게 한다고 하면 어디선가 오류가 발생했을 때 문제를 찾는 데 더 오랜 시간이 걸릴 수도 있기 때문이다. 따라서 테스트 케이스를 줄이는 건 괜찮은 생각같지 않았다.</p>
<p>2. 레이어별 테스트 케이스</p>
<p>발생 가능한 모든 케이스를 레이어마다 테스트해야할까? 그래야 하는 곳도 있지만, 특정 레이어 이후 레이어를 거치지 않는 경우는 해당 상황을 테스트하기 어려운 경우도 있었다. 예를 들어, 빈 유효성 검증 로직을 서비스 레이어에 적용했을 경우, 요청 데이터가 유효하지 않을 경우 검증 로직이 있는 레이어 이후 레이어로는 입력이 갈 수 없기 때문에 유효성 검증 실패 여부에 따른 동작 확인은 DAO 레이어에서는 할 수 없다. 또한 예외 처리 로직 흐름에 따라 단위 테스트는 불가능하고 통합 테스트나 E2E 테스트로만 해당 케이스를 확인할 수 있는 경우도 있다.</p>
<p>테스트하려는 레이어 이후 레이어에서 조건에 따라 다른 방식으로 처리하는 로직이 있을 경우, 테스트에선 각 조건에 대한 케이스를 고려해야 할까? 구현한 getTodos API는 사용자의 요청값(all/incomplete/complete)에 따라서 결과를 다르게 처리해준다. 요청값의 조건에 따라 처리하는 로직은 DAO 레이어인 UserMapper에 있다. UserController @WebMvcTest 테스트에선 각 케이스를 모두 테스트해야할까?</p>
<p>x. 행동을 유발할 데이터의 범위</p>
<p>특정 값을 갖는 데이터에 대해서만 행동을 유발하도록 범위를 좁게 할 수도 있지만, 특정 타입을 갖는 데이터라면 행동을 유발하도록 범위를 넓게 할 수도 있다.</p>
<p>전에는 특정 값이 들어와야지만 행동이 발생하도록 테스트를 만들었지만, 굳이 그럴 필요가 있을까 생각이 들었다. 특정 값은 내가 테스트 데이터를 만들 때 필드 값으로 설정한 값인데, 지금은 이 값이 해당 케이스에 유효하다고 할 수 있지만, 나중에 코드가 변경되었을 때도 동일하게 유효하다고 할 수는 없을 것 같기 때문이다.</p>
<p>3. 특정 값일 필요 없는 테스트 데이터 하드코딩</p>
<p>테스트 데이터를 하드코딩했던 테스트 중 스프링 애플리케이션 컨텍스트를 띄우지 않는 단위 테스트는 테스트 데이터가 실제로 그 상황을 일으키는 값이 아니더라도 동작한다. 데이터를 넘겨줄 객체는 실제 객체가 아니라 행동을 직접 정의한 모의 객체이기 때문이다.</p>
<p>특정 값을 필요로 하는 로직이 아니라면 실제로 의미 있는 값이 굳이 필요할까 하는 의문이 들었다.</p>
<p>각 케이스에 대한 이유를 테스트 데이터에 나타내기 위해 테스트 메서드마다 실패 원인이 되는 필드값을 갖는 데이터를 새로 만들었다. 하지만 실제로 이렇게 만들었을 때, 오히려 관리가 힘들어졌다. 실패 원인이 되는 필드값은 실제 환경에서도 실패 원인이 되는 것이 있기도 했지만, 그렇지 않고 단지 강조하기 위한 목적인 것도 있었다. 각 테스트 데이터를 만들기 위한 선언문 때문에 테스트가 길어졌지만, 이걸로 얻는 건 크지 않았다.</p>
<p>이런 테스트는 '내가 생각하는 데이터를 테스트 메서드의 입력으로 제공했을 때 테스트에서 원하는 결과를 내줄 것이다'는 생각을 기반으로 한다.</p>
<p>EasyRandom으로 이런 부분을 단순하게 만들었다. EasyRandom은 인자로 받은 타입에 대한 임의의 인스턴스를 돌려준다. 어떤 값이 들어가야 하는지가 중요한 게 아니라면 필드마다 어떤 값을 넣을지 고민하지 않아도 되는 것이다. EasyRandom으로 바꾼 테스트는 모든 테스트 메서드의 테스트 데이터로 동일한 필드값을 가진 데이터를 쓴다. 실제 환경일 때 어떻게 응답할지는 고려하지 않고, 협력하는 객체의 모의 객체가 각 케이스에서 어떻게 행동할지만 확인하는 것이다.</p>
<p>---------------------------------------------------------------------------------------------------------------</p>
<p>예를 들어 회원 도메인과 관련된 UserController의 단위 테스트에서 회원가입 로직을 테스트한다고 해보자. 다음과 같은 테스트할만한 케이스를 생각해볼 수 있을 것 같다:</p>
<p>1) 회원가입이 성공할 경우 2) 회원가입이 실패할 경우</p>
<p>만약 회원가입이 실패하는 이유가 여러 가지가 될 수 있다면, 각각의 실패 케이스에 대한 테스트를 만들 것이다. 내가 구현한 앱에서는 UserService가 각 실패 여부를 확인한다. 하지만 각 케이스에 대한 이유를 테스트 데이터에 나타내기 위해 테스트 메서드마다 실패 원인이 되는 필드값을 갖는 데이터를 새로 만들었다. 하지만 실제로 이렇게 만들었을 때, 오히려 관리가 힘들어졌다. 실패 원인이 되는 필드값은 실제 환경에서도 실패 원인이 되는 것이 있기도 했지만, 그렇지 않고 단지 강조하기 위한 목적인 것도 있었다. 각 테스트 데이터를 만들기 위한 선언문 때문에 테스트가 길어졌지만, 이걸로 얻는 건 크지 않았다.</p>
<p>UserService의 단위 테스트를 살펴보자. 이 테스트에서는 UserMapper의 행위를 정의한다. 지금까지 만들었던 테스트에선 DAO가 입력받는 DTO 타입 데이터를 일일이 정의하고, DTO의 필드로 DAO에 메서드를 호출했을 때 도메인 객체가 반환되는지를 확인했다.</p>
<p>4. 특정 값이어야 하는 테스트 데이터 하드코딩</p>
<p>스프링 애플리케이션 컨텍스트를 띄우는 통합 테스트나 E2E 테스트는 실제 의존 객체를 가져오기 때문에, 테스트 데이터가 임의의 값을 가지면 테스트가 실패할 수 있다. 따라서 테스트 데이터의 값은 테스트로 확인하고자 하는 상황을 일으키는 값이어야 한다.</p>
<p>Mapper 테스트는 @SpringBootTest로 정의되어 있기 때문에 스프링 애플리케이션 컨텍스트를 띄운다. 그래서 실제 환경인 DB의 상태를 고려해야 한다. 회원 찾기가 실패하는 케이스를 테스트한다고 할 때, 이를테면 요청한 회원 아이디와 일치하는 회원 정보가 DB에 없으면 테스트가 실패할 것이다. 따라서 테스트 데이터는 1) DB에 저장되어 있는 회원의 값과 일치하지 않아야 하고, 2) 테스트에서 추가한 회원 테스트 데이터가 있다면 이 값과 일치하지 않아야 한다. 이전에 만든 테스트에선 위 둘과 다르도록 값을 설정했다. 하지만 테스트를 통과했더라도 그것이 실제 환경을 반영하는 것을 의미하는 것은 아니다. 그렇다면 굳이 어떤 값을 넣을지를 고민할 필요가 있을까? 단순히 위 두 값과 일치하지 않는 값을 만들기만 하면 그만이다.</p>
<p>테스트 케이스 중에는 유효성 검증이 잘 되는지, 잘못된 값이 들어갔을 때 적절하게 응답하는지 확인하는 것도 있다. 이런 테스트는 객체의 값이 특정해야 한다. 결론적으로 특정 값을 필드값으로 하는 객체를 EasyRandom으로 생성할 수 있어야 하고, 이 라이브러리를 도입하게 된 목적인 '테스트를 전보다 깔끔하게 하는' 목적을 달성해야 한다. 이걸 어떻게 할지가 문제였다. 이를 각 상황에 맞는 필드값을 갖는 임의의 테스트 데이터를 만들어내도록 Randomizer를 새로 정의해서 해결했다.</p>
<p>특정 데이터를 갖는 상황을 만들어내기 위해 Randomizer를 새로 정의하는 건 괜찮은 걸까? 새로운 관리 포인트를 만들어내는 건 아닐까?</p>
<p>5. 테스트 데이터 이름 짓기</p>
<p>메서드마다의 테스트 데이터는 서로 공통인 필드값이 많지만, 각 상황에 맞는 변수 이름으로 데이터를 선언하고, 그 메서드에서 테스트하고자 하는 상황의 원인이 되는 필드값 역시 적절한 이름을 붙이려다보니 각 메서드마다 데이터를 갖게 되었다.</p>
<p>필드 이름에 맞는 값을 생각하는 건 생각했던 것만큼 금방 되지 않았다.</p>
<p>어떤 상황을 테스트하려고 하는지는 테스트 메서드 이름에서 알려줄 수 있다. 하드코딩된 데이터는 다른 상황에 대한 테스트의 데이터와 그다지 다른 점이 없다. 하드코딩된 데이터가 갖는 장점이 있다면, 데이터의 변수명과 필드값의 변수명이 그 상황에 대해 추가로 설명해준다는 것인데, 테스트 갯수가 일정 수준을 넘어선 다음부턴 테스트 메서드 내부를 일일이 살펴보는 데만 해도 시간이 많이 소요되어서 그다지 도움이 되지 않았다. 따라서 테스트 메서드 이름에서 어떤 상황을 테스트하려고 하는 것인지 잘 나타낸다면 테스트 데이터를 테스트 메서드마다 새로 만들 필요는 없다고 결론내렸다.</p>
<p>?</p>
<p>해당 레이어 이외의 레이어는 모의 객체로 만들어서 행동만 정의하고, 성공, 실패, 예외 상황 등 API를 구현하는 메서드가 처할 수 있는 상황에 대한 테스트 메서드를 구현한다.</p>