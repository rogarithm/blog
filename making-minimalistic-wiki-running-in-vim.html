<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="./css/main.css" type="text/css" media="screen" />
	</head>
	<body>
		<div class="site">
			<div class="title">
			</div>
			<h2> 텍스트 에디터 기반 위키?</h2>
<p>
  누군가가 위키에 대해 이야기하면 흔히 쉽게 떠올릴 수 있는 한 번쯤은 위키피디아나 나무위키를 들어본 적이 있을 것이다. 웹 기반 위키다. 웹 페이지에 들어가서 위키 문서를 수정하거나 새로 쓸 수 있다. 텍스트 에디터 기반으로 돌아가는 위키도 있다. 이 위키는 텍스트 에디터로 위키 문서를 편집하고, 열람할 수 있게 해준다. 웹 기반 위키가 내 컴퓨터와 멀리 떨어진 서버에 위키 문서를 저장하는 반면, 텍스트 에디터 기반 위키는 내 컴퓨터의 파일 시스템에 위키 문서를 저장한다. 그래서 보통은 혼자서 쓰기 때문에 일종의 개인 위키라고 할 수 있다.
</p>
<p>
  5년도 더 전에 실용주의 사고와 학습이란 책을 읽다가 이런 위키가 있다는 걸 알게 되었다. 책에서 작가는 여러 방식으로 개인 위키를 활용한 경험을 이야기한다. 그 중 PDA에 위키 엔진을 설치하고 휴대용 키보드를 달아서 어디서나 위키 문서를 편집할 수 있는 환경을 구성해 본 경험은 멋져 보였다. 나는 오랫동안 소스 코드 작성뿐 아니라 문서 작업에도 텍스트 에디터인 vim을 써왔는데, 이 텍스트 에디터 위에서 돌아가는 위키 엔진을 만들어서 개인 위키로 써보고 싶었다.
</p>
<h2> 뭘 어떻게 만들어야 할까?</h2>
<p>
  몇 번 개인 위키를 만들어보려고 시도했지만, 그때마다 번번이 실패했다. 직접 짜보려고 보니 뭘 어떻게 만들어야 할지 몰랐다. 그래서 다른 사람이 짠 소스를 참고하려고 알아봤다. 텍스트 에디터 기반 위키는 거의 없다시피 했다. 웹 기반 위키는 심심치 않게 찾을 수 있었지만, 결과적으론 참고할 수 없었다. 왜냐면 너무 오래된 프로젝트라 페이지 자체가 사라졌거나, 내가 잘 모르는 언어로 되어있거나, 아는 언어이더라도 이해하기 어려울 정도로 복잡했기 때문이었다.
</p>
<p>
  사정이 이렇다보니 아쉬운대로 다른 사람이 만들어놓은 개인 위키를 써보기도 했다. vimwiki는 오픈소스로 공개된 개인 위키인데, 이름에서 알 수 있듯 내가 만들려는 환경과 동일한 프로젝트다. 한동안 써봤지만 나한텐 잘 맞지 않았다. 이미 개발이 많이 되어있는 프로젝트여서인지 설정부터 쉽지 않았다. 설정을 어떻게 하는지 설명해주는(!) 블로그를 따라한 뒤에야 가까스로 써볼 수 있었다. 이런 과정에서 알 수 있듯 내가 모르는 부분이 많았고, 이런 걸 다 이해하고 나한테 맞는 방식으로 바꾸기엔 들일 수 있는 시간도, 내 실력도 부족했다.
</p>
<p>
  개인 위키를 만들려는 시도는 그 후로도 종종 했다. 그러던 중, 워드 커닝햄(최초로 위키를 만든 프로그래머다)의 깃헙을 돌아다니다 small-again-wiki라는 프로젝트를 발견했다. 웹 기반으로 만들어진 위키 엔진이라 조금 아쉬웠지만, 코드도 그리 길지 않았고 루비로 짠 프로젝트라 비교적 이해하기 수월했다. 테스트 코드를 추가해서 어떤 식으로 돌아가는지 확인해보는 방식으로 프로젝트를 분석하면서 어떤 걸 만들어야할지 감을 잡을 수 있었다.
</p>
<h2> 위키 엔진이 할 줄 알아야 하는 일</h2>
<p>
  좀처럼 만들지 못했던 지난 날이 무색하게, 위키 엔진은 그렇게 복잡한 게 아니었다. 위키 엔진 역시 클라이언트와 서버 간에 통신할 수 있는 프로그램이다. 위키 엔진은 어떤 일을 할 줄 알아야 할까. 위키 엔진이 웹 기반이든 텍스트 에디터 기반이든 상관없이 다음과 같은 CRUD 요청을 생각해볼 수 있다.
</p>
<ul>
  <li>C(reate): 사용자는 새로운 위키 문서를 만들 수 있다</li>
  <li>R(ead): 사용자는 위키 문서를 읽을 수 있다</li>
  <li>U(pdate): 사용자는 만들어진 위키 문서를 수정할 수 있다</li>
  <li>D(elete): 사용자는 만들어진 위키 문서를 삭제할 수 있다</li>
</ul>
<p>
  다른 건 각 방식이 어떤 식으로 이들 동작을 구현하는지다. 웹 기반 위키에서 위키 문서를 읽는 동작을 생각해보면 이런 식이다.
</p>
<ul>
  <li>사용자가 웹 페이지 상의 링크를 클릭한다</li>
  <li>위키 엔진으로 요청이 전달된다</li>
  <li>위키 엔진은 요청에 담긴 정보를 토대로 위키 문서를 검색한다</li>
  <li>찾아낸 문서를 볼 수 있는 웹 페이지로 리다이렉션해 사용자에게 응답으로 전달한다</li>
</ul>
<p>
  텍스트 에디터 기반 위키 엔진일 경우, 전체적인 흐름은 같은 대신 전달 방식이 조금 달라진다.
</p>
<ul>
  <li>사용자가 텍스트 에디터로 띄운 문서 내 링크 위에 커서를 대고 단축키를 입력한다</li>
  <li>위키 엔진으로 요청이 전달된다</li>
  <li>위키 엔진은 요청에 담긴 정보를 토대로 위키 문서를 검색한다</li>
  <li>찾아낸 문서를 텍스트 에디터 상에 띄워 사용자에게 응답으로 전달한다</li>
</ul>
<p>
  그러니까 텍스트 에디터 기반 위키 엔진에선 사용자가 텍스트 에디터 상에서 특정 단축키를 누르고, 그 단축키가 위키 엔진의 어떤 기능을 호출하게 된다.
</p>
<h2> 어떻게 구현했나?</h2>
<p>
  vimscript로 개발했고, 파일 조작 관련 연산은 vimscript로 터미널 명령어를 실행하도록 구현했다. 혼자 쓸 용도이기 때문에 내가 필요하다고 생각하는 최소한의 기능과 예외 상황 처리를 구현하고, 쓰면서 필요해지는 기능을 추가로 개발하고 있다. 최소한의 기능은 위키 문서를 생성하는 것과, 링크를 통해 위키 문서로 이동해 읽을 수 있도록 해주는 것이다.
</p>
<p>
  구현하면서 중점적으로 고민한 부분은 "웹 기반 위키의 동작 방식을 텍스트 에디터 기반 위키에선 어떻게 구현할 것인가"였다. 다음 다섯 가지다.
</p>
<ul>
  <li>링크 표현 방식</li>
  <li>위키 엔트리 포인트</li>
  <li>위키 문서 저장</li>
  <li>설치 방법</li>
  <li>예외 처리</li>
</ul>
<p>
  링크를 만들 수 있는 링크 이름을 문서의 다른 내용과 구분하고자 했다. 한글명 위키 파일명도 생각해보고, 스네이크 케이스나 케밥 케이스도 생각해봤지만, 전통적인 C2 위키에서 쓰는, 첫 문자가 대문자인 카멜 케이스가 괜찮아 보였다. 그래서 카멜 케이스인 키워드 위에 커서를 두고 위키 링크 생성 단축키를 눌렀을 때에만 링크를 생성하도록 구현했다. 웹 기반 위키에서 링크는 a 태그로 표현한다. (당연하게도) 텍스트 에디터에서 다루는 파일은 html이 아니어도 상관없기 때문에, 그리고 나는 주로 포맷도 없는 파일을 다루기 때문에, 이 방식은 적용하기 어려웠다. 내가 구현하는 프로그램이니만큼 내 마음대로 쓸 수 있겠지만, 다른 사람이 쓰는 방식이 있다면 따르고 싶었다. 실용주의 사고와 학습의 작가가 만든 위키에서 쓰는 형식을 차용했다. 그래서 문서에서 위키 문서에 연결된 링크는 [:WikiDocument:] 형식으로 표현한다.
</p>
<p>
  위키 문서의 엔트리 포인트는 링크로 연결된 문서들의 입구가 되는 역할을 맡는 파일이다. 파일 이름 역시 내 마음대로 정할 수 있지만, 단순하게 index를 이름으로 하는 파일을 엔트리 포인트로 정했다. index 파일은 root 디렉토리와 마찬가지로 모든 위키 문서의 최상위 문서가 된다.
</p>
<p>
  문서는 위키 index 파일이 있는 디렉토리의 wiki 디렉토리에 저장한다. Gollum과 같은 위키 엔진에서 이 방식을 쓴다. 중첩된 디렉토리 구조를 쓰지 않기 때문에 파일명이 중복될 수 있다는 단점이 있지만, 나의 사용 환경에서 그런 상황이 몇 년간 발생할 것 같지는 않다.
</p>
<p>
  내가 구현한 위키는 플러그인 형태가 아니어서, 다른 방법으로 위키 기능을 불러올 수 있는 방법을 쓰고 있다. 위키 문서가 있는 디렉토리에 wiki.vim을 심볼릭 링크로 연결하고, 해당 디렉토리의 index 파일을 vim으로 열었을 때 wiki.vim 스크립트를 로드한다. 이건 다음과 같은 vim의 trigger 기능을 써서 특정 위치의 파일을 열었을 때 vim 스크립트를 로드하도록 하고 있다.
</p>
<p>
  <pre>autocmd! BufReadPost ~/writing/wiki/index source %:h/wiki.vim</pre>
</p>
<p>
  하나의 거대한 위키를 만들어서 여러 주제를 포함할 수 있게 하기보단 각 주제마다 독립적인 위키를 만들어서 개별적으로 관리하고 있기 때문에, 이런 위키 갯수가 많아지면 위 설정도 하나씩 늘어날 것이다. 하지만 그건 그때 가서 고민할 문제다.
</p>
<p>
  예외 처리는 문제가 생겼을 때 어떤 상황인지 내가 인지하고, 그에 대해 적절한 해결책을 생각해낼 수 있을 정도로 구현하고자 했다. 예를 들어, 
</p>
<h2> 개인 위키의 효용</h2>
<p>
  개인 위키를 만든 이후, 회사와 개인 용도로 쓰고 있다. 크게 세 가지로 쓰고 있는데,
</p>
<ul>
  <li>회사에서 개발하는 솔루션의 공통 기능 및 동작 원리를 분석하기 위한 것</li>
  <li>그때마다 진행하는 프로젝트 제반 정보(할 일 등 기록해놓아야 하는 것들)를 정리하기 위한 것</li>
  <li>개인적으로 필요해서 알아본 프로그램 사용법, 언어 사용법이나 사이드 프로젝트 아이디어, 블로깅할만한 글감 등을 모아놓는 것</li>
</ul>
<p>
  이렇게 세 가지다.
</p>
<p>
  개인적으로 경험해본 바로는, 위키를 쓸 때 이전에 해왔던 정리 방식에 비해 좋았던 몇 가지 점들이 있다. 할 일 목록을 예로 들면, 시간이 지날수록 어느샌가 할 일 목록이 눈더미처럼 불어나있다. 그때그때 일이 끝나서 다 끝난 일을 지우면 좋겠지만, 맘같이 되지 않고, 끝난 일이더라도 기록을 남겨둬야 할 때도 있다. 한 파일이 너무 길어져서 파일을 여러 개로 쪼개면 새로운 파일 이름을 어떻게 지을지 고민하게 되고, 파일 사이를 왔다갔다 하느라 번거롭다.
</p>
<p>
  위키를 쓰면서는 할 일 목록이 불어났을 때 텍스트 에디터를 벗어나지 않은 채로 새로운 위키 파일을 만들어서 내용을 분리할 수 있게 되었다. 문서 사이를 오가는 것도 단축키 한 번이면 된다. 위키 문서도 링크 이름을 만들어야 하지만, 적절한 링크 이름을 생각해내지 못했더라도 적당히 짓고 그 옆에 설명을 덧붙여놓으면 나중에 찾기 쉽다. 어떻게 보면 정리하는 걸 뒤로 미룰 수 있게 만들어준 것뿐 아닌가 생각할 수도 있지만, 이게 중요하다. 굳이 당장 잘 해놓을 필요 없는 일에 시간을 쏟지 않을 수 있게 해주고, 다음에 언제라도 여유가 생기면 더 잘 다듬을 수 있게 해준다는 점이 문서 작업에 느끼는 저항감을 줄여준다고 느끼기 때문이다.
</p>

		</div>
	</body>
</html>
